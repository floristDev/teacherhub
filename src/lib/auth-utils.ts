// Generated by LFG (Let's Fucking Go) â€” SaaS Autopilot
// 2026-02-27T00:07:12.322Z

import { auth } from "@/lib/auth";
import { redirect } from "next/navigation";

// ---------------------------------------------------------------------------
// Password hashing via Web Crypto API (no native dependencies)
// ---------------------------------------------------------------------------

const ITERATIONS = 100_000;
const HASH_ALGORITHM = "SHA-256";
const KEY_LENGTH = 32; // bytes

function bufferToBase64(buffer: ArrayBuffer): string {
  return Buffer.from(buffer).toString("base64");
}

function base64ToBuffer(base64: string): ArrayBuffer {
  return Buffer.from(base64, "base64");
}

export async function hashPassword(password: string): Promise<string> {
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const saltBase64 = bufferToBase64(salt.buffer);

  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(password),
    { name: "PBKDF2" },
    false,
    ["deriveBits"]
  );

  const derivedBits = await crypto.subtle.deriveBits(
    {
      name: "PBKDF2",
      salt,
      iterations: ITERATIONS,
      hash: HASH_ALGORITHM,
    },
    keyMaterial,
    KEY_LENGTH * 8
  );

  const hashBase64 = bufferToBase64(derivedBits);
  return `${ITERATIONS}:${saltBase64}:${hashBase64}`;
}

export async function verifyPassword(
  password: string,
  stored: string
): Promise<boolean> {
  const parts = stored.split(":");
  if (parts.length !== 3) return false;

  const [iterStr, saltBase64, hashBase64] = parts;
  const iterations = parseInt(iterStr, 10);

  const salt = new Uint8Array(base64ToBuffer(saltBase64));

  const keyMaterial = await crypto.subtle.importKey(
    "raw",
    new TextEncoder().encode(password),
    { name: "PBKDF2" },
    false,
    ["deriveBits"]
  );

  const derivedBits = await crypto.subtle.deriveBits(
    {
      name: "PBKDF2",
      salt,
      iterations,
      hash: HASH_ALGORITHM,
    },
    keyMaterial,
    KEY_LENGTH * 8
  );

  const candidateHash = bufferToBase64(derivedBits);
  return candidateHash === hashBase64;
}

// ---------------------------------------------------------------------------
// Session helpers
// ---------------------------------------------------------------------------

export interface SessionUser {
  id: string;
  email: string;
  name: string | null;
  image: string | null;
  role: string;
  organizationId: string | null;
}

/**
 * Returns the current session user, or null if not authenticated.
 * Safe to call from Server Components and Server Actions.
 */
export async function getCurrentUser(): Promise<SessionUser | null> {
  const session = await auth();
  if (!session?.user?.id) return null;
  return session.user as SessionUser;
}

/**
 * Returns the current session user. Redirects to /login if not authenticated.
 */
export async function requireAuth(): Promise<SessionUser> {
  const user = await getCurrentUser();
  if (!user) {
    redirect("/login");
  }
  return user;
}

/**
 * Returns the current session user. Throws a 403 if the user's role does not
 * match one of the allowed roles.
 *
 * @param allowedRoles - One or more role slugs that are permitted.
 */
export async function requireRole(
  ...allowedRoles: string[]
): Promise<SessionUser> {
  const user = await requireAuth();

  if (!allowedRoles.includes(user.role)) {
    throw new Error(
      `Forbidden: role '${user.role}' is not in [${allowedRoles.join(", ")}]`
    );
  }

  return user;
}

/**
 * Returns the current session user. Throws a 403 if the user does not belong
 * to an organization. Use this in routes that require a valid org context.
 */
export async function requireOrg(): Promise<SessionUser & { organizationId: string }> {
  const user = await requireAuth();

  if (!user.organizationId) {
    throw new Error("Forbidden: no organization context");
  }

  return user as SessionUser & { organizationId: string };
}
